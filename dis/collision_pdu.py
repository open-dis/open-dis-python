from enum import Enum

from .siso_ref_010.enums.collision_type import CollisionType
from .siso_ref_010.enums.dis_pdu_type import DisPduType
from .entity_information_interaction_family_pdu import EntityInformationInteractionFamilyPdu
from .vector3float import Vector3Float
from .entity_id import EntityID
from .event_identifier import EventIdentifier

class CollisionPdu( EntityInformationInteractionFamilyPdu ):
    """7.2.3 Collisions between entities shall be communicated by issuing a Collision PDU. See 5.3.3."""

    def __init__(self):
        """ Initializer for CollisionPdu"""
        super().__init__()
        """ This field shall identify the entity that is issuing the PDU, and shall be represented by an Entity Identifier record (see 6.2.28)."""
        self.issuingEntityID = EntityID()
        """ This field shall identify the entity that has collided with the issuing entity (see 5.3.3.4). This field shall be represented by an Entity Identifier record (see 6.2.28)."""
        self.collidingEntityID = EntityID()
        """ This field shall contain an identification generated by the issuing simulation application to associate related collision events. This field shall be represented by an Event Identifier record (see 6.2.34)."""
        self.eventID = EventIdentifier()
        # /** This field shall identify the type of collision. The Collision Type field shall be represented by an 8-bit record of enumerations uid 189 */
        self.collisionType = CollisionType.default

        """ some padding"""
        self.pad = 0
        """ This field shall contain the velocity (at the time the collision is detected) of the issuing entity. The velocity shall be represented in world coordinates. This field shall be represented by the Linear Velocity Vector record [see 6.2.95 item c)]."""
        self.velocity = Vector3Float()
        """ This field shall contain the mass of the issuing entity, and shall be represented by a 32-bit floating point number representing kilograms."""
        self.mass = 0.0
        """ This field shall specify the location of the collision with respect to the entity with which the issuing entity collided. The Location field shall be represented by an Entity Coordinate Vector record [see 6.2.95 item a)]."""
        self.location = Vector3Float()
        self.pduType = DisPduType.collision

    def to_string(self) ->str:
        outputString = ""
        outputString += super().to_string()
        outputString += "IssuingEntityID :" + "\n" + self.issuingEntityID.to_string() + "\n"
        outputString += "CollidingEntityID :" + "\n" + self.collidingEntityID.to_string() + "\n"
        outputString += "EventID :" + "\n" + self.eventID.to_string() + "\n"
        outputString += "CollisionType : " + self.collisionType.get_description + "(" + (str(int(self.collisionType))) + ")" + "\n"
        outputString += "Pad : " + str(self.pad) + "\n"
        outputString += "Velocity :" + "\n" + self.velocity.to_string() + "\n"
        outputString += "Mass : " + str(self.mass) + "\n"
        outputString += "Location :" + "\n" + self.location.to_string() + "\n"
        return outputString

    def __str__(self):
        return self.to_string()

    def serialize_enum(self, enumValue, outputStream):
        enumSize = enumValue.get_marshaled_size()
        marshallers = {8 : 'byte', 16 : 'short', 32 : 'int'}
        marshalFunction = getattr(outputStream, 'write_unsigned_' + marshallers[enumSize])
        result = marshalFunction(int(enumValue))

    def parse_enum(self, enumValue, intputStream) -> int:
        enumSize = enumValue.get_marshaled_size()
        marshallers = {8 : 'byte', 16 : 'short', 32 : 'int'}
        marshalFunction = getattr(intputStream, 'read_unsigned_' + marshallers[enumSize])
        return marshalFunction()

    def serialize(self, outputStream):
        """serialize the class """
        super( CollisionPdu, self ).serialize(outputStream)
        self.issuingEntityID.serialize(outputStream)
        self.collidingEntityID.serialize(outputStream)
        self.eventID.serialize(outputStream)
        self.serialize_enum(self.collisionType,outputStream)
        outputStream.write_byte(int(self.pad))
        self.velocity.serialize(outputStream)
        outputStream.write_float(int(self.mass))
        self.location.serialize(outputStream)

    def parse(self, inputStream):
        """"Parse a message. This may recursively call embedded objects."""
        super( CollisionPdu, self).parse(inputStream)
        self.issuingEntityID.parse(inputStream)
        self.collidingEntityID.parse(inputStream)
        self.eventID.parse(inputStream)
        self.collisionType = CollisionType.get_enum(self.parse_enum(self.collisionType,inputStream))
        self.pad = inputStream.read_byte()
        self.velocity.parse(inputStream)
        self.mass = inputStream.read_float()
        self.location.parse(inputStream)

    # Get the number of attributes defined by SISO
    def get_design_attribute_count(self) -> int:
        return 8

    def get_attribute_count(self) -> int:
        attrList = list()
        for attr in dir(self):
            if not callable(getattr(self, attr)):
                if not attr.startswith("__"):
                    if not hasattr(self.__class__.__base__(), attr):
                        attrList.append(attr)
        return len(attrList)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def diff(self,other) -> set:
        diffs = set()
        for key, value in self.__dict__.items():
            value2 = other.__dict__[key]
            if (value != value2):
                if type(value) is list:
                    diffs.add((key, str(value)))
                    diffs.add((key, str(value2)))
                elif (type(value).__module__ == "builtins"):
                    diffs.add((key, value))
                    diffs.add((key, value2))
                elif (isinstance(value, Enum)):
                    diffs.add((key, value))
                    diffs.add((key, value2))
                elif (isinstance(value, object)):
                    diffs.update(value.diff(value2))
                else:
                    diffs.add((key, value))
                    diffs.add((key, value2))
        return(diffs)



