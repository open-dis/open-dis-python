from enum import Enum

from .munition_descriptor import MunitionDescriptor
from .siso_ref_010.enums.dis_pdu_type import DisPduType
from .vector3float import Vector3Float
from .warfare_family_pdu import WarfareFamilyPdu
from .vector3double import Vector3Double
from .entity_id import EntityID
from .event_identifier import EventIdentifier

class FirePdu( WarfareFamilyPdu ):
    """7.3.2 Used to communicate the firing of a weapon or expendable."""

    def __init__(self):
        """ Initializer for FirePdu"""
        super().__init__()
        """ ID of the entity that shot"""
        self.firingEntityID = EntityID()
        """ ID of the entity that is being shot at"""
        self.targetEntityID = EntityID()
        """ This field shall specify the entity identification of the fired munition or expendable. This field shall be represented by an Entity Identifier record (see 6.2.28)."""
        self.munitionExpendibleID = EntityID()
        """ This field shall contain an identification generated by the firing entity to associate related firing and detonation events. This field shall be represented by an Event Identifier record (see 6.2.34)."""
        self.eventID = EventIdentifier()
        """ This field shall identify the fire mission (see 5.4.3.3). This field shall be represented by a 32-bit unsigned integer."""
        self.fireMissionIndex = 0
        """ This field shall specify the location, in world coordinates, from which the munition was launched, and shall be represented by a World Coordinates record (see 6.2.97)."""
        self.locationInWorldCoordinates = Vector3Double()
        """ This field shall describe the firing or launch of a munition or expendable represented by one of the following types of Descriptor records: Munition Descriptor (6.2.20.2) or Expendable Descriptor (6.2.20.4)."""
        self.descriptor = MunitionDescriptor()
        """ This field shall specify the velocity of the fired munition at the point when the issuing simulation application intends the externally visible effects of the launch (e.g. exhaust plume or muzzle blast) to first become apparent. The velocity shall be represented in world coordinates. This field shall be represented by a Linear Velocity Vector record [see 6.2.95 item c)]."""
        self.velocity = Vector3Float()
        """ This field shall specify the range that an entity's fire control system has assumed in computing the fire control solution. This field shall be represented by a 32-bit floating point number in meters. For systems where range is unknown or unavailable, this field shall contain a value of zero."""
        self.range = 0.0
        self.pduType = DisPduType.fire

    def to_string(self) ->str:
        outputString = ""
        outputString += super().to_string()
        outputString += "FiringEntityID :" + "\n" + self.firingEntityID.to_string() + "\n"
        outputString += "TargetEntityID :" + "\n" + self.targetEntityID.to_string() + "\n"
        outputString += "MunitionExpendibleID :" + "\n" + self.munitionExpendibleID.to_string() + "\n"
        outputString += "EventID :" + "\n" + self.eventID.to_string() + "\n"
        outputString += "FireMissionIndex : " + str(self.fireMissionIndex) + "\n"
        outputString += "LocationInWorldCoordinates :" + "\n" + self.locationInWorldCoordinates.to_string() + "\n"
        outputString += "Descriptor :" + "\n" + self.descriptor.to_string() + "\n"
        outputString += "Velocity :" + "\n" + self.velocity.to_string() + "\n"
        outputString += "Range : " + str(self.range) + "\n"
        return outputString

    def __str__(self):
        return self.to_string()

    def serialize_enum(self, enumValue, outputStream):
        enumSize = enumValue.get_marshaled_size()
        marshallers = {8 : 'byte', 16 : 'short', 32 : 'int'}
        marshalFunction = getattr(outputStream, 'write_unsigned_' + marshallers[enumSize])
        result = marshalFunction(int(enumValue))

    def parse_enum(self, enumValue, intputStream) -> int:
        enumSize = enumValue.get_marshaled_size()
        marshallers = {8 : 'byte', 16 : 'short', 32 : 'int'}
        marshalFunction = getattr(intputStream, 'read_unsigned_' + marshallers[enumSize])
        return marshalFunction()

    def serialize(self, outputStream):
        """serialize the class """
        super( FirePdu, self ).serialize(outputStream)
        self.firingEntityID.serialize(outputStream)
        self.targetEntityID.serialize(outputStream)
        self.munitionExpendibleID.serialize(outputStream)
        self.eventID.serialize(outputStream)
        outputStream.write_int(int(self.fireMissionIndex))
        self.locationInWorldCoordinates.serialize(outputStream)
        self.descriptor.serialize(outputStream)
        self.velocity.serialize(outputStream)
        outputStream.write_float(int(self.range))

    def parse(self, inputStream):
        """"Parse a message. This may recursively call embedded objects."""
        super( FirePdu, self).parse(inputStream)
        self.firingEntityID.parse(inputStream)
        self.targetEntityID.parse(inputStream)
        self.munitionExpendibleID.parse(inputStream)
        self.eventID.parse(inputStream)
        self.fireMissionIndex = inputStream.read_int()
        self.locationInWorldCoordinates.parse(inputStream)
        self.descriptor.parse(inputStream)
        self.velocity.parse(inputStream)
        self.range = inputStream.read_float()

    # Get the number of attributes defined by SISO
    def get_design_attribute_count(self) -> int:
        return 9

    def get_attribute_count(self) -> int:
        attrList = list()
        for attr in dir(self):
            if not callable(getattr(self, attr)):
                if not attr.startswith("__"):
                    if not hasattr(self.__class__.__base__(), attr):
                        attrList.append(attr)
        return len(attrList)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def diff(self,other) -> set:
        diffs = set()
        for key, value in self.__dict__.items():
            value2 = other.__dict__[key]
            if (value != value2):
                if type(value) is list:
                    diffs.add((key, str(value)))
                    diffs.add((key, str(value2)))
                elif (type(value).__module__ == "builtins"):
                    diffs.add((key, value))
                    diffs.add((key, value2))
                elif (isinstance(value, Enum)):
                    diffs.add((key, value))
                    diffs.add((key, value2))
                elif (isinstance(value, object)):
                    diffs.update(value.diff(value2))
                else:
                    diffs.add((key, value))
                    diffs.add((key, value2))
        return(diffs)



